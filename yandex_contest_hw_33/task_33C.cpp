/*
 Используйте unordered_set для реализации множества строк.
 Хранимые строки  – непустые последовательности  длиной не более 10 символов, состоящие из строчных латинских букв.
 Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки
 принадлежности данной строки множеству. Максимальное количество элементов в хранимом множестве не превосходит 106.

 Формат ввода
 Каждая строка входных данных задает одну операцию над множеством.
 Запись операции состоит из типа операции и следующей за ним через пробел строки, над которой проводится операция.
 Тип операции – один из трех символов:
 +  означает добавление данной строки в множество;
 -  означает удаление  строки из множества;
 ?  означает проверку принадлежности данной строки множеству.
 Общее количество операций во входном файле не превосходит 106. Список операций завершается строкой, в которой записан
 один символ # – признак конца входных данных.

 При добавлении элемента в множество НЕ ГАРАНТИРУЕТСЯ, что он отсутствует в этом множестве. При удалении элемента из
 множества НЕ ГАРАНТИРУЕТСЯ, что он присутствует в этом множестве.

 Формат вывода
 Программа должна вывести для каждой операции типа ? одну из двух строк YES или NO, в зависимости от того, встречается
 ли данное слово в нашем множестве.
*/

#include <iostream>
#include <unordered_set>

using namespace std;

int main33C() {
    unordered_set<string> unord_set;
    string s;
    char oper;

    while (cin >> oper) {
        cin >> s;

        switch (oper) {
            case '+':
                if (unord_set.find(s) == unord_set.cend()) {
                    unord_set.emplace(s);
                }
                break;
            case '-': {
                auto it = unord_set.find(s);
                if (it != unord_set.cend()) {
                    unord_set.erase(it);
                }
                break;
            }
            case '?':
                if (unord_set.find(s) != unord_set.cend()) {
                    cout << "YES" << endl;
                }
                else {
                    cout << "NO" << endl;
                }
                break;
        }
    }
}

